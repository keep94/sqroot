// Package sqroot calculates square roots to arbitrary precision.
package sqroot

import (
	"fmt"
	"io"
	"math/big"
	"os"
	"strconv"
	"strings"

	"github.com/keep94/consume2"
)

const (
	fPrecision = 6
	gPrecision = 16
)

var (
	oneHundred = big.NewInt(100)
	two        = big.NewInt(2)
	one        = big.NewInt(1)
	ten        = big.NewInt(10)
)

// Option represents a Print Mantissa option.
type Option interface {
	mutate(p *printerSettings)
}

// DigitsPerRow sets the number of digits per row. The default is
// zero, which means no separate rows.
func DigitsPerRow(count int) Option {
	return optionFunc(func(p *printerSettings) {
		p.digitsPerRow = count
	})
}

// DigitsPerColumn sets the number of digits per column. The default is
// zero, which means no separate columns.
func DigitsPerColumn(count int) Option {
	return optionFunc(func(p *printerSettings) {
		p.digitsPerColumn = count
	})
}

// ShowCount shows the digit count in the left margin if on is true. The
// default is false.
func ShowCount(on bool) Option {
	return optionFunc(func(p *printerSettings) {
		p.showCount = on
	})
}

// Mantissa represents the mantissa of a square root. Non-nil Mantissas are
// between 0.1 inclusive and 1.0 exclusive. A nil Mantissa means 0.
type Mantissa func(consumer consume2.Consumer[int])

// Format prints this Mantissa with the f, F, g, and G verbs. The verbs work
// in the usual way except that they always round down. Because Mantissas can
// have an infinite number of digits, g with no precision shows a max of 16
// significant digits. Format supports width, precision, and the '-' flag
// for left justification. The v verb is an alias for g.
func (m Mantissa) Format(state fmt.State, verb rune) {
	var gverb bool
	switch verb {
	case 'f', 'F':
		gverb = false
	case 'g', 'G', 'v':
		gverb = true
	default:
		fmt.Fprintf(state, "%%!%c(mantissa=%s)", verb, m.String())
		return
	}
	precision, precisionOk := state.Precision()
	if !precisionOk {
		if gverb {
			precision = gPrecision
		} else {
			precision = fPrecision
		}
	}
	if precision == 0 && gverb {
		precision = 1
	}
	trailingZeros := !gverb
	width, widthOk := state.Width()
	if !widthOk {
		m.printWithPrecision(state, precision, trailingZeros)
		return
	}
	var builder strings.Builder
	m.printWithPrecision(&builder, precision, trailingZeros)
	field := builder.String()
	if !state.Flag('-') && len(field) < width {
		fmt.Fprint(state, strings.Repeat(" ", width-len(field)))
	}
	fmt.Fprint(state, field)
	if state.Flag('-') && len(field) < width {
		fmt.Fprint(state, strings.Repeat(" ", width-len(field)))
	}
}

// String returns the decimal representation of m as generated by m.Sprint(16).
func (m Mantissa) String() string {
	return m.Sprint(gPrecision)
}

// Send sends the digits to the right of decimal point of this Mantissa
// to consumer. If this Mantissa is nil, which means 0, Send sends no digits
// to consumer.
func (m Mantissa) Send(consumer consume2.Consumer[int]) {
	if m != nil {
		m(consumer)
	}
}

// Print prints this Mantissa to stdout. Print returns the number of bytes
// written and any error encountered.
func (m Mantissa) Print(maxDigits int, options ...Option) (n int, err error) {
	return m.Fprint(os.Stdout, maxDigits, options...)
}

// Sprint prints this Mantissa to a string.
func (m Mantissa) Sprint(maxDigits int, options ...Option) string {
	var builder strings.Builder
	m.Fprint(&builder, maxDigits, options...)
	return builder.String()
}

// Fprint prints this Mantissa to w. Fprint returns the number of bytes
// written and any error encountered.
func (m Mantissa) Fprint(w io.Writer, maxDigits int, options ...Option) (
	n int, err error) {
	if m == nil {
		return fmt.Fprint(w, "0")
	}
	p := newPrinter(w, maxDigits, options)
	m.Send(p)
	return p.byteCount, p.err
}

func (m Mantissa) printWithPrecision(
	w io.Writer, precision int, trailingZeros bool) {
	f := newFormatter(w, precision, 0, trailingZeros)
	m.Send(f)
	f.Finish()
}

// Number represents a square root value. The zero value of Number is 0.
type Number struct {
	Mantissa Mantissa
	Exponent int
}

// Format prints this Number with the f, F, g, G, e, E verbs. The verbs work
// in the usual way except that they always round down. Because Number can
// have an infinite number of digits, g with no precision shows a max of 16
// significant digits. Format supports width, precision, and the '-' flag
// for left justification. The v verb is an alias for g.
func (n Number) Format(state fmt.State, verb rune) {
	if n.Mantissa == nil {
		n.Exponent = 0
	}
	precision, precisionOk := state.Precision()
	var sigDigits int
	var exactDigitCount bool
	var sci bool
	switch verb {
	case 'f', 'F':
		if !precisionOk {
			precision = fPrecision
		}
		sigDigits = precision + n.Exponent
		exactDigitCount = true
		sci = false
	case 'g', 'G', 'v':
		if !precisionOk {
			precision = gPrecision
		}
		sigDigits = precision
		if sigDigits == 0 {
			sigDigits = 1
		}
		exactDigitCount = false
		sci = sigDigits < n.Exponent || n.bigExponent()
	case 'e', 'E':
		if !precisionOk {
			precision = fPrecision
		}
		sigDigits = precision
		exactDigitCount = true
		sci = true
	default:
		fmt.Fprintf(state, "%%!%c(number=%s)", verb, n.String())
		return
	}
	capital := verb == 'E' || verb == 'G'
	width, widthOk := state.Width()
	if !widthOk {
		n.printNumber(state, sigDigits, exactDigitCount, sci, capital)
		return
	}
	var builder strings.Builder
	n.printNumber(&builder, sigDigits, exactDigitCount, sci, capital)
	field := builder.String()
	if !state.Flag('-') && len(field) < width {
		fmt.Fprint(state, strings.Repeat(" ", width-len(field)))
	}
	fmt.Fprint(state, field)
	if state.Flag('-') && len(field) < width {
		fmt.Fprint(state, strings.Repeat(" ", width-len(field)))
	}
}

// String returns the decimal representation of n using %g.
func (n Number) String() string {
	if n.Mantissa == nil {
		n.Exponent = 0
	}
	var builder strings.Builder
	n.printNumber(&builder, gPrecision, false, n.bigExponent(), false)
	return builder.String()
}

func (n Number) bigExponent() bool {
	return n.Exponent < -3 || n.Exponent > 10
}

func (n Number) printNumber(
	w io.Writer, sigDigits int, exactDigitCount, sci, capital bool) {
	if sci {
		sep := "e"
		if capital {
			sep = "E"
		}
		n.printSci(w, sigDigits, exactDigitCount, sep)
	} else {
		n.printFixed(w, sigDigits, n.Exponent, exactDigitCount)
	}
}

func (n Number) printFixed(
	w io.Writer, sigDigits, exponent int, exactDigitCount bool) {
	f := newFormatter(w, sigDigits, exponent, exactDigitCount)
	n.Mantissa.Send(f)
	f.Finish()
}

func (n Number) printSci(
	w io.Writer, sigDigits int, exactDigitCount bool, sep string) {
	n.printFixed(w, sigDigits, 0, exactDigitCount)
	fmt.Fprint(w, sep)
	fmt.Fprint(w, n.Exponent)
}

// Compute returns the square root of radican * 10^rexp.
// If radican is 0, Compute returns the zero value of Number.
func Compute(radican *big.Int, rexp int) Number {
	m, e := SquareRoot(radican, rexp)
	return Number{Mantissa: m, Exponent: e}
}

// SquareRoot returns the square root of radican * 10^rexp. The return value
// is of the form mantissa * 10^exp. mantissa is between 0.1 inclusive
// and 1.0 exclusive. If radican is 0, SquareRoot returns nil for mantissa
// and 0 for exp.
func SquareRoot(radican *big.Int, rexp int) (mantissa Mantissa, exp int) {
	if radican.Sign() < 0 {
		panic("radican must be non-negative")
	}
	if radican.Sign() == 0 {
		return
	}
	if rexp%2 != 0 {
		radican = new(big.Int).Mul(radican, ten)
		rexp--
	}
	radicanDigits, doubleZeroCount := base100(radican)
	exp = len(radicanDigits) + doubleZeroCount + rexp/2
	mantissa = func(consumer consume2.Consumer[int]) {
		squareRoot(radicanDigits, consumer)
	}
	return
}

type printer struct {
	writer          io.Writer
	maxDigits       int
	indentation     string
	digitCountSpec  string
	digitsPerRow    int
	digitsPerColumn int
	index           int
	indexInRow      int
	byteCount       int
	err             error
}

func newPrinter(
	writer io.Writer, maxDigits int, options []Option) *printer {
	settings := &printerSettings{}
	for _, option := range options {
		option.mutate(settings)
	}
	indentation, digitCountSpec := computeIndentation(
		settings.digitCountWidth(maxDigits))
	return &printer{
		writer:          writer,
		maxDigits:       maxDigits,
		indentation:     indentation,
		digitCountSpec:  digitCountSpec,
		digitsPerRow:    settings.digitsPerRow,
		digitsPerColumn: settings.digitsPerColumn,
	}
}

func (p *printer) CanConsume() bool {
	return p.err == nil && p.index < p.maxDigits
}

func (p *printer) Consume(digit int) {
	if !p.CanConsume() {
		return
	}
	if p.index == 0 {
		n, err := fmt.Fprintf(p.writer, "%s0.", p.indentation)
		if !p.updateByteCount(n, err) {
			return
		}
	} else if p.digitsPerRow > 0 && p.index%p.digitsPerRow == 0 {
		n, err := fmt.Fprintln(p.writer)
		if !p.updateByteCount(n, err) {
			return
		}
		if p.digitCountSpec != "" {
			n, err := fmt.Fprintf(p.writer, p.digitCountSpec, p.index)
			if !p.updateByteCount(n, err) {
				return
			}
		}
		n, err = fmt.Fprint(p.writer, "  ")
		if !p.updateByteCount(n, err) {
			return
		}
		p.indexInRow = 0
	} else if p.digitsPerColumn > 0 && p.indexInRow%p.digitsPerColumn == 0 {
		n, err := fmt.Fprint(p.writer, " ")
		if !p.updateByteCount(n, err) {
			return
		}
	}
	n, err := fmt.Fprint(p.writer, digit)
	if !p.updateByteCount(n, err) {
		return
	}
	p.index++
	p.indexInRow++
}

func (p *printer) updateByteCount(n int, err error) bool {
	p.byteCount += n
	p.err = err
	return err == nil
}

type formatter struct {
	writer          io.Writer
	sigDigits       int // invariant sigDigits >= exponent
	exponent        int
	exactDigitCount bool
	index           int
}

func newFormatter(
	w io.Writer, sigDigits, exponent int, exactDigitCount bool) *formatter {
	if sigDigits < exponent {
		panic("sigDigits must be >= exponent")
	}
	return &formatter{
		writer:          w,
		sigDigits:       sigDigits,
		exponent:        exponent,
		exactDigitCount: exactDigitCount,
	}
}

func (f *formatter) CanConsume() bool {
	return f.index < f.sigDigits
}

func (f *formatter) Consume(digit int) {
	if !f.CanConsume() {
		return
	}
	f.add(digit)
}

func (f *formatter) Finish() {
	maxDigits := f.sigDigits
	if !f.exactDigitCount {
		maxDigits = f.exponent
	}
	for f.index < maxDigits {
		f.add(0)
	}
	// If we haven't written anything yet
	if f.index == 0 {
		count := -f.exponent
		if f.exactDigitCount {
			count = f.sigDigits - f.exponent
		}
		f.addLeadingZeros(count)
	}
}

func (f *formatter) add(digit int) {
	if f.index == 0 && f.exponent <= 0 {
		f.addLeadingZeros(-f.exponent)
	}
	if f.index == f.exponent {
		fmt.Fprint(f.writer, ".")
	}
	fmt.Fprint(f.writer, digit)
	f.index++
}

func (f *formatter) addLeadingZeros(count int) {
	fmt.Fprint(f.writer, "0")
	if count <= 0 {
		return
	}
	fmt.Fprint(f.writer, ".")
	fmt.Fprint(f.writer, strings.Repeat("0", count))
}

func squareRoot(radicanDigits []*big.Int, consumer consume2.Consumer[int]) {
	radicanDigitsIdx := len(radicanDigits)
	incr := big.NewInt(1)
	remainder := big.NewInt(0)
	for consumer.CanConsume() {
		if radicanDigitsIdx == 0 && remainder.Sign() == 0 {
			return
		}
		remainder.Mul(remainder, oneHundred)
		if radicanDigitsIdx > 0 {
			radicanDigitsIdx--
			remainder.Add(remainder, radicanDigits[radicanDigitsIdx])
		}
		digit := 0
		for remainder.Cmp(incr) >= 0 {
			remainder.Sub(remainder, incr)
			digit++
			incr.Add(incr, two)
		}
		consumer.Consume(digit)
		incr.Sub(incr, one).Mul(incr, ten).Add(incr, one)
	}
}

func base100(radican *big.Int) (result []*big.Int, doubleZeroCount int) {
	radican = new(big.Int).Set(radican)
	trailingZeros := true
	for radican.Sign() > 0 {
		_, m := radican.DivMod(radican, oneHundred, new(big.Int))
		if trailingZeros && m.Sign() == 0 {
			doubleZeroCount++
		} else {
			result = append(result, m)
			trailingZeros = false
		}
	}
	return
}

type optionFunc func(p *printerSettings)

func (o optionFunc) mutate(p *printerSettings) {
	o(p)
}

type printerSettings struct {
	digitsPerRow    int
	digitsPerColumn int
	showCount       bool
}

func (p *printerSettings) digitCountWidth(maxDigits int) int {
	if !p.showCount || p.digitsPerRow <= 0 {
		return 0
	}
	if maxDigits <= p.digitsPerRow {
		return 0
	}
	maxCounter := ((maxDigits - 1) / p.digitsPerRow) * p.digitsPerRow
	return len(strconv.Itoa(maxCounter))
}

func computeIndentation(width int) (
	indentation string, digitCountSpec string) {
	if width <= 0 {
		return
	}
	indentation = strings.Repeat(" ", width)
	digitCountSpec = fmt.Sprintf("%%%dd", width)
	return
}
